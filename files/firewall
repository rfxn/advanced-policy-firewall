#!/bin/bash
#
##
# Advanced Policy Firewall (APF) v1.7.6
#             (C) 2002-2019, R-fx Networks <proj@rfxn.com>
#             (C) 2019, Ryan MacDonald <ryan@rfxn.com>
# This program may be freely redistributed under the terms of the GNU GPL v2
##
#
CNF="/etc/apf/conf.apf"

if [ -f "$CNF" ] && [ ! "$CNF" == "" ]; then
   source $CNF
else
   head
   echo "\$CNF not found; aborting"
   exit 1
fi

if [ ! -f "$ip" ] && [ ! -f "$ifconfig" ]; then
	eout "{glob} $ip and $ifconfig not found; aborting"
	exit 1
fi

# load our iptables modules
modinit

# Delete user made chains. Flush and zero the chains.
flush 1

if [ ! "$IF" == "" ] && [ "$VF_ROUTE" == "1" ]; then
 for i in `echo $IF`; do
  VAL_IF=`/sbin/route -n | grep -w $i`
	if [ "$VAL_IF" == "" ]; then
		eout "{glob} could not verify that interface $IF is routed to a network, aborting."
	        if [ ! "$SET_VERBOSE" == "1" ]; then
			echo "could not verify that interface $IF is routed to a network, aborting."
		fi
		exit 1
	fi
 done
fi
if [ ! "$IFACE_TRUSTED" == "" ] && [ "$VF_ROUTE" == "1" ]; then
 for i in `echo $IFACE_TRUSTED | tr ',' ' '`; do
  VAL_IFACE_TRUSTED=`/sbin/route -n | grep -w $i`
        if [ "$VAL_IFACE_TRUSTED" == "" ]; then
                eout "{glob} could not verify that interface $IFACE_TRUSTED is routed to a network, aborting."
	        if [ ! "$SET_VERBOSE" == "1" ]; then
			echo "could not verify that interface $IFACE_TRUSTED is routed to a network, aborting."
		fi
                exit 1
        fi
 done
fi

if [ "$DLIST_PHP" == "1" ] || [ "$DLIST_SPAMHAUS" == "1" ] || [ "$DLIST_DSHIELD" == "1" ] || [ "$DLIST_RESERVED" == "1" ] || [ "$DLIST_ECNSHAME" == "1" ] || [ "$USE_RGT" == "1" ]; then
	if [ ! -f "$WGET" ]; then
		echo "DLIST_* or RGT enabled but wget binary not found, aborting"
		exit 1
	fi
fi

/sbin/ip addr list $IFACE_UNTRUSTED | grep -w inet | grep -v inet6 | tr '/' ' ' | awk '{print$2}' > /etc/apf/internals/.localaddrs

if [ "$RAB" == "0" ]; then
	RAB_LOG_HIT=0
fi

eout "{glob} determined (IFACE_UNTRUSTED) $IFACE_UNTRUSTED has address $NET"

# Load our PREROUTE rules
tosroute PREROUTING
. $PRERT

# Allow all traffic on the loopback interface
if [ $EXECUTOR == "nft" ]; then
   #$IPT $IPT_FLAGS -A INPUT -i lo -s 0/0 -d 0/0 -j ACCEPT
   $NFT add rule ip filter INPUT iifname "lo" counter accept
   #$IPT $IPT_FLAGS -A OUTPUT -o lo -s 0/0 -d 0/0 -j ACCEPT
   $NFT add rule ip filter OUTPUT oifname "lo" counter accept
   if [ "$USE_IPV6" == "1" ]; then
   #	$IP6T -A INPUT -i lo -s 0/0 -d 0/0 -j ACCEPT
   #	$IP6T -A OUTPUT -o lo -s 0/0 -d 0/0 -j ACCEPT
        $NFT add rule ip6 filter INPUT iifname "lo" counter accept
        $NFT add rule ip6 filter OUTPUT oifname "lo" counter accept
   fi
else
   $IPT $IPT_FLAGS -A INPUT -i lo -s 0/0 -d 0/0 -j ACCEPT
   $IPT $IPT_FLAGS -A OUTPUT -o lo -s 0/0 -d 0/0 -j ACCEPT
   if [ "$USE_IPV6" == "1" ]; then
	$IP6T -A INPUT -i lo -s 0/0 -d 0/0 -j ACCEPT
	$IP6T -A OUTPUT -o lo -s 0/0 -d 0/0 -j ACCEPT
   fi
fi


# Allow all traffic on trusted interfaces
if [ ! "$IFACE_TRUSTED" == "" ]; then
 for i in `echo $IFACE_TRUSTED | tr ',' ' '`; do
 VAL_IF=`/sbin/ip addr list | grep -w $i`
 if [ "$VAL_IF" == "" ]; then
        eout "{glob} unable to verify status of interface $i; assuming untrusted"
 else
        eout "{glob} allow all to/from trusted interface $i"
	if [ $EXECUTOR == "nft" ]; then
          #$IPT $IPT_FLAGS -A INPUT -i $i -s 0/0 -d 0/0 -j ACCEPT
          #$IPT $IPT_FLAGS -A OUTPUT -o $i -s 0/0 -d 0/0 -j ACCEPT
          $NFT add rule ip filter INPUT iifname "$i" counter accept
          $NFT add rule ip filter OUTPUT oifname "$i" counter accept
        else
          $IPT $IPT_FLAGS -A INPUT -i $i -s 0/0 -d 0/0 -j ACCEPT
          $IPT $IPT_FLAGS -A OUTPUT -o $i -s 0/0 -d 0/0 -j ACCEPT
	fi
 fi
 done
fi

# Create TCP RESET & UDP PROHIBIT chains
if [ $EXECUTOR == "nft" ]; then
   #$IPT $IPT_FLAGS -N RESET
   #$IPT $IPT_FLAGS -A RESET -p tcp -j REJECT --reject-with tcp-reset
   #$IPT $IPT_FLAGS -N PROHIBIT
   #$IPT $IPT_FLAGS -A PROHIBIT -j REJECT --reject-with icmp-host-prohibited
   $NFT add chain ip filter RESET
   $NFT add rule ip filter RESET ip protocol tcp counter reject with tcp reset
   $NFT add chain ip filter PROHIBIT
   $NFT add rule ip filter PROHIBIT counter reject with icmp type host-prohibited
else
   $IPT $IPT_FLAGS -N RESET
   $IPT $IPT_FLAGS -A RESET -p tcp -j REJECT --reject-with tcp-reset
   $IPT $IPT_FLAGS -N PROHIBIT
   $IPT $IPT_FLAGS -A PROHIBIT -j REJECT --reject-with icmp-host-prohibited
fi

# Load our SYSCTL rules
. $INSTALL_PATH/sysctl.rules >> /dev/null 2>&1

# Fix MTU/MSS Problems
if [ $EXECUTOR == "nft" ]; then
   #$IPT $IPT_FLAGS -A OUTPUT -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
   $NFT add rule ip filter OUTPUT tcp "flags & (syn|rst) == syn" counter tcp option maxseg size set rt mtu
else
   $IPT $IPT_FLAGS -A OUTPUT -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
fi

# Block common nonroutable IP networks
if [ "$BLK_MCATNET" = "1" ]; then
	dnet $MCATNET
fi
if [ "$BLK_PRVNET" = "1" ]; then
	dnet $PRVNET
fi
if [ "$BLK_RESNET" = "1" ]; then
	if [ "$DLIST_RESERVED" == "1" ]; then
		dlist_resnet
	fi
	dnet $RESNET
fi

# Create (glob)trust system chains
if [ $EXECUTOR == "nft" ]; then
  $NFT add chain ip filter TALLOW
  $NFT add chain ip filter TDENY
  $NFT add chain ip filter TGALLOW
  $NFT add chain ip filter TGDENY
  $NFT add chain ip filter REFRESH_TEMP
  $NFT add rule ip filter INPUT counter jump REFRESH_TEMP
  $NFT add rule ip filter OUTPUT counter jump REFRESH_TEMP
  $NFT add rule ip filter INPUT counter jump TALLOW
  $NFT add rule ip filter OUTPUT counter jump TALLOW
  $NFT add rule ip filter INPUT counter jump TGALLOW
  $NFT add rule ip filter OUTPUT counter jump TGALLOW
  $NFT add rule ip filter INPUT counter jump TDENY
  $NFT add rule ip filter OUTPUT counter jump TDENY
  $NFT add rule ip filter INPUT counter jump TGDENY
  $NFT add rule ip filter OUTPUT counter jump TGDENY

  if [ "$USE_IPV6" = "1" ]; then
    $NFT add chain ip6 filter TALLOW
    $NFT add chain ip6 filter TDENY
    $NFT add chain ip6 filter TGALLOW
    $NFT add chain ip6 filter TGDENY

    $NFT add rule ip6 filter INPUT counter jump TALLOW
    $NFT add rule ip6 filter OUTPUT counter jump TALLOW
    $NFT add rule ip6 filter INPUT counter jump TGALLOW
    $NFT add rule ip6 filter OUTPUT counter jump TGALLOW
    $NFT add rule ip6 filter INPUT counter jump TDENY
    $NFT add rule ip6 filter OUTPUT counter jump TDENY
    $NFT add rule ip6 filter INPUT counter jump TGDENY
    $NFT add rule ip6 filter OUTPUT counter jump TGDENY
  fi
else
  $IPT $IPT_FLAGS -N TALLOW
  $IPT $IPT_FLAGS -N TDENY
  $IPT $IPT_FLAGS -N TGALLOW
  $IPT $IPT_FLAGS -N TGDENY
  $IPT $IPT_FLAGS -N REFRESH_TEMP
  $IPT $IPT_FLAGS -A INPUT -j REFRESH_TEMP
  $IPT $IPT_FLAGS -A OUTPUT -j REFRESH_TEMP
  $IPT $IPT_FLAGS -A INPUT -j TALLOW
  $IPT $IPT_FLAGS -A OUTPUT -j TALLOW
  $IPT $IPT_FLAGS -A INPUT -j TGALLOW
  $IPT $IPT_FLAGS -A OUTPUT -j TGALLOW
  $IPT $IPT_FLAGS -A INPUT -j TDENY
  $IPT $IPT_FLAGS -A OUTPUT -j TDENY
  $IPT $IPT_FLAGS -A INPUT -j TGDENY
  $IPT $IPT_FLAGS -A OUTPUT -j TGDENY

  if [ "$USE_IPV6" = "1" ]; then
    $IP6T -N TALLOW
    $IP6T -N TDENY
    $IP6T -N TGALLOW
    $IP6T -N TGDENY

    $IP6T -A INPUT -j TALLOW
    $IP6T -A OUTPUT -j TALLOW
    $IP6T -A INPUT -j TGALLOW
    $IP6T -A OUTPUT -j TGALLOW
    $IP6T -A INPUT -j TDENY
    $IP6T -A OUTPUT -j TDENY
    $IP6T -A INPUT -j TGDENY
    $IP6T -A OUTPUT -j TGDENY
  fi
fi

# Load our Blocked Traffic rules
. $INSTALL_PATH/bt.rules

# Set refresh cron
cron_refresh

# Load our Allow Hosts rules
glob_allow_download
allow_hosts $GALLOW_HOSTS TGALLOW
allow_hosts $ALLOW_HOSTS TALLOW

# RAB default drop for events
check_rab
if [ "$RAB" == "1" ]; then
 eout "{rab} set active RAB"
 if [ "$RAB_HITCOUNT" == "0" ]; then
	RAB_HITCOUNT="1"
 fi

 if [ "$RAB_TRIP" == "0" ]; then
	RAB_TRIP_FLAGS="--rcheck"
 else
	RAB_TRIP_FLAGS="--update"
 fi

 if [ "$LOG_DROP" == "1" ] || [ "$RAB_LOG_TRIP" == "1" ]; then
    if [ $EXECUTOR == "nft" ]; then
           # TODO nft
           :
    else
           $IPT $IPT_FLAGS -A INPUT -p all -m recent --rcheck --hitcount $RAB_HITCOUNT --seconds $RAB_TIMER -m limit --limit=$LOG_RATE/minute -j $LOG_TARGET --log-level=$LOG_LEVEL $LEXT --log-prefix="** RABTRIP ** "
    fi
 fi
 if [ $EXECUTOR == "nft" ]; then
    # TODO nft
    :
 else
    $IPT $IPT_FLAGS -A INPUT -p all -m recent $RAB_TRIP_FLAGS --hitcount $RAB_HITCOUNT --seconds $RAB_TIMER -j $ALL_STOP
 fi

 # RAB portscan rules
 if [ ! "$RAB_PSCAN_LEVEL" == "0" ] || [ ! "$RAB_PSCAN_LEVEL" == "" ]; then
  eout "{rab} set active RAB_PSCAN"
  case "$RAB_PSCAN_LEVEL" in
  1)
  RAB_PSCAN_PORTS="$RAB_PSCAN_LEVEL_1"
  ;;
  2)
  RAB_PSCAN_PORTS="$RAB_PSCAN_LEVEL_2"
  ;;
  3)
  RAB_PSCAN_PORTS="$RAB_PSCAN_LEVEL_3"
  esac
  eout "{rab} RAB_PSCAN monitored ports $RAB_PSCAN_PORTS"
  if [ $EXECUTOR == "nft" ]; then
     $NFT add chain ip filter RABPSCAN
  else
     $IPT $IPT_FLAGS -N RABPSCAN
  fi
  LDNS=`cat /etc/resolv.conf  | grep -v "#" | grep -w nameserver | awk '{print$2}' | grep -v 127.0.0.1`
  if [ "$LDNS" ]; then
	for i in `echo $LDNS`; do
	        if [ $EXECUTOR == "nft" ]; then
		   $NFT insert rule ip filter RABPSCAN ip saddr $i counter return
                else
		   $IPT $IPT_FLAGS -I RABPSCAN -s $i -j RETURN
		fi
	done
  fi
  for i in `echo $RAB_PSCAN_PORTS | tr ',' ' '`; do
   if [ "$LOG_DROP" == "1" ] || [ "$RAB_LOG_HIT" == "1" ]; then
	   if [ $EXECUTOR == "nft" ]; then
	      $NFT add rule ip filter RABPSCAN tcp dport $i limit rate $LOG_RATE/minute burst 5 packets counter log prefix '"** RABHIT ** "' level $LOG_LEVEL $LEXT
	      $NFT add rule ip filter RABPSCAN udp dport $i limit rate $LOG_RATE/minute burst 5 packets counter log prefix '"** RABHIT ** "' level $LOG_LEVEL $LEXT
      else
	      $IPT $IPT_FLAGS -A RABPSCAN -p tcp --dport $i -m limit --limit=$LOG_RATE/minute -j $LOG_TARGET --log-level=$LOG_LEVEL $LEXT --log-prefix="** RABHIT ** "
	      $IPT $IPT_FLAGS -A RABPSCAN -p udp --dport $i -m limit --limit=$LOG_RATE/minute -j $LOG_TARGET --log-level=$LOG_LEVEL $LEXT --log-prefix="** RABHIT ** "
	   fi
   fi
   if [ $EXECUTOR == "nft" ]; then
      # TODO nft
      :
   else
      $IPT $IPT_FLAGS -A RABPSCAN -p tcp --dport $i -m recent --set -j $TCP_STOP
      $IPT $IPT_FLAGS -A RABPSCAN -p udp --dport $i -m recent --set -j $UDP_STOP
   fi
  done
  if [ $EXECUTOR == "nft" ]; then
     $NFT add rule ip filter INPUT counter jump RABPSCAN
  else
     $IPT $IPT_FLAGS -A INPUT -j RABPSCAN
  fi
 fi
fi

trim $DENY_HOSTS $SET_TRIM
trim $GDENY_HOSTS $SET_TRIM

# Load our LOG rules
. $INSTALL_PATH/log.rules

# Virtual Adapters
. $INSTALL_PATH/vnet/main.vnet

# Clear any cport values
cl_cports
. $CNF

# Load our main TCP/UDP rules
if [ "$SET_VNET" == "1" ]; then
	VNET="$NET"
	if [ "$USE_IPV6" == "1" ]; then
	  VNET="$IP6_NET"
	fi
else
	VNET="0/0"
fi
. $INSTALL_PATH/main.rules

# Drop NEW tcp connections after this point
if [ $EXECUTOR == "nft" ]; then
   $NFT add rule ip filter INPUT tcp "flags & (fin|syn|rst|ack) != syn" ct state new  counter jump $ALL_STOP
   $NFT add rule ip filter INPUT ip protocol tcp ct state related,established  counter accept
   $NFT add rule ip filter INPUT ip protocol udp ct state related,established  counter accept
   $NFT add rule ip filter OUTPUT tcp dport 1024-65535 ct state related,established  counter accept
   $NFT add rule ip filter OUTPUT udp dport 1024-65535 ct state related,established  counter accept
   if [ "$USE_IPV6" == "1" ]; then
      $NFT add rule ip6 filter INPUT ct state related,established counter accept
   fi
else
   $IPT $IPT_FLAGS -A INPUT  -p tcp ! --syn -m state --state NEW -j $ALL_STOP
   $IPT $IPT_FLAGS -A INPUT  -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT
   $IPT $IPT_FLAGS -A INPUT  -p udp -m state --state ESTABLISHED,RELATED -j ACCEPT
   $IPT $IPT_FLAGS -A OUTPUT  -p tcp --dport 1024:65535 -m state --state ESTABLISHED,RELATED -j ACCEPT
   $IPT $IPT_FLAGS -A OUTPUT  -p udp --dport 1024:65535 -m state --state ESTABLISHED,RELATED -j ACCEPT
   if [ "$USE_IPV6" == "1" ]; then
      $IP6T -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
   fi
fi

# DNS
if [ -f "/etc/resolv.conf" ] && [ "$RESV_DNS" == "1" ]; then
LDNS=`cat /etc/resolv.conf  | grep -v "#" | grep -w nameserver | awk '{print$2}' | grep -v 127.0.0.1`
  if [ ! "$LDNS" == "" ]; then
        for i in `echo $LDNS`; do
        eout "{glob} resolv dns discovery for $i"
        if [ $EXECUTOR == "nft" ]; then
           $NFT add rule ip filter INPUT ip saddr $i udp sport 53 udp dport 1023-65535 counter accept
           $NFT add rule ip filter INPUT ip saddr $i tcp sport 53 tcp dport 1023-65535 counter accept
           $NFT add rule ip filter OUTPUT ip daddr $i udp sport 1023-65535 udp dport 53 counter accept
           $NFT add rule ip filter OUTPUT ip daddr $i tcp sport 1023-65535 tcp dport 53 counter accept
           if [ "$RESV_DNS_DROP" == "1" ]; then
              $NFT add rule ip filter OUTPUT ip daddr $i udp sport 1023-65535 udp dport 53 counter accept
              $NFT add rule ip filter OUTPUT ip daddr $i tcp sport 1023-65535 tcp dport 53 counter accept
           fi
        else
           $IPT $IPT_FLAGS -A INPUT -p udp -s $i --sport 53 --dport 1023:65535 -j ACCEPT
           $IPT $IPT_FLAGS -A INPUT -p tcp -s $i --sport 53 --dport 1023:65535 -j ACCEPT
           $IPT $IPT_FLAGS -A OUTPUT -p udp -d $i --dport 53 --sport 1023:65535 -j ACCEPT
           $IPT $IPT_FLAGS -A OUTPUT -p tcp -d $i --dport 53 --sport 1023:65535 -j ACCEPT
           if [ "$RESV_DNS_DROP" == "1" ]; then
                $IPT $IPT_FLAGS -A OUTPUT -p udp -d $i --dport 53 --sport 1023:65535 -j ACCEPT
                $IPT $IPT_FLAGS -A OUTPUT -p tcp -d $i --dport 53 --sport 1023:65535 -j ACCEPT
           fi
        fi
        done
        if [ $EXECUTOR == "nft" ]; then
           if [ "$RESV_DNS_DROP" == "1" ]; then
              $NFT add rule ip filter INPUT tcp sport 53 tcp dport 1023-65535 counter jump $ALL_STOP
              $NFT add rule ip filter INPUT udp sport 53 udp dport 1023-65535 counter jump $ALL_STOP
           fi
        else
           if [ "$RESV_DNS_DROP" == "1" ]; then
              $IPT $IPT_FLAGS -A INPUT  -p tcp -s 0/0 --sport 53 --dport 1023:65535 -j $ALL_STOP
              $IPT $IPT_FLAGS -A INPUT  -p udp -s 0/0 --sport 53 --dport 1023:65535 -j $ALL_STOP
           fi
        fi
  fi
else
	if [ $EXECUTOR == "nft" ]; then
           $NFT add rule ip filter INPUT udp sport 53 udp dport 1023-65535 counter accept
           $NFT add rule ip filter INPUT tcp sport 53 tcp dport 1023-65535 counter accept
           $NFT add rule ip filter OUTPUT udp sport 53 udp dport 1023-65535 counter accept
           $NFT add rule ip filter OUTPUT tcp sport 53 tcp dport 1023-65535 counter accept
        else
           $IPT $IPT_FLAGS -A INPUT  -p udp --sport 53 --dport 1023:65535 -j ACCEPT
           $IPT $IPT_FLAGS -A INPUT  -p tcp --sport 53 --dport 1023:65535 -j ACCEPT
           $IPT $IPT_FLAGS -A OUTPUT -p udp --dport 53 --sport 1023:65535 -j ACCEPT
           $IPT $IPT_FLAGS -A OUTPUT -p tcp --dport 53 --sport 1023:65535 -j ACCEPT
	fi
fi

# FTP
if [ "$HELPER_FTP" == "1" ]; then
	if [ $EXECUTOR == "nft" ]; then
	   $NFT add rule ip filter INPUT tcp sport 1023-65535 tcp dport $HELPER_FTP_PORT ct state related,established  counter accept
	   $NFT add rule ip filter INPUT ip protocol tcp tcp dport { $HELPER_FTP_PORT,$HELPER_FTP_DATA } ct state related,established  counter accept
	   $NFT add rule ip filter INPUT ip protocol udp udp dport { $HELPER_FTP_PORT,$HELPER_FTP_DATA } ct state related,established  counter accept
	   $NFT add rule ip filter OUTPUT tcp sport $HELPER_FTP_PORT tcp dport 1023-65535 ct state related,established  counter accept
	   $NFT add rule ip filter OUTPUT ip protocol tcp tcp dport { $HELPER_FTP_PORT,$HELPER_FTP_DATA } ct state related,established  counter accept
	   $NFT add rule ip filter OUTPUT ip protocol udp udp dport { $HELPER_FTP_PORT,$HELPER_FTP_DATA } ct state related,established  counter accept
   else
	   $IPT $IPT_FLAGS -A INPUT  -p tcp --sport 1023:65535 --dport $HELPER_FTP_PORT -m state --state RELATED,ESTABLISHED -j ACCEPT
	   $IPT $IPT_FLAGS -A INPUT  -p tcp -m multiport --dport $HELPER_FTP_PORT,$HELPER_FTP_DATA -m state --state ESTABLISHED,RELATED -j ACCEPT
	   $IPT $IPT_FLAGS -A INPUT  -p udp -m multiport --dport $HELPER_FTP_PORT,$HELPER_FTP_DATA -m state --state ESTABLISHED,RELATED -j ACCEPT
	   $IPT $IPT_FLAGS -A OUTPUT  -p tcp --dport 1023:65535 --sport $HELPER_FTP_PORT -m state --state RELATED,ESTABLISHED -j ACCEPT
	   $IPT $IPT_FLAGS -A OUTPUT  -p tcp -m multiport --dport $HELPER_FTP_PORT,$HELPER_FTP_DATA -m state --state ESTABLISHED,RELATED -j ACCEPT
	   $IPT $IPT_FLAGS -A OUTPUT  -p udp -m multiport --dport $HELPER_FTP_PORT,$HELPER_FTP_DATA -m state --state ESTABLISHED,RELATED -j ACCEPT
	fi
fi

# SSH
if [ "$HELPER_SSH" == "1" ]; then
	if [ $EXECUTOR == "nft" ]; then
	   $NFT add rule ip filter INPUT tcp sport  $HELPER_SSH_PORT tcp dport 513-65535 ct state related,established  counter accept
	   $NFT add rule ip filter INPUT tcp sport 1024-65535 tcp dport $HELPER_SSH_PORT tcp "flags & (fin|syn|rst|ack) == syn" ct state related,established  counter accept
	   $NFT add rule ip filter INPUT udp dport $HELPER_SSH_PORT ct state established  counter accept
	   if [ "$USE_IPV6" == "1" ]; then
		   $NFT add rule ip6 filter INPUT ct state new  tcp dport $HELPER_SSH_PORT counter accept
      fi
   else
	   $IPT $IPT_FLAGS -A INPUT  -p tcp --sport $HELPER_SSH_PORT --dport 513:65535 -m state --state ESTABLISHED,RELATED -j ACCEPT
	   $IPT $IPT_FLAGS -A INPUT  -p tcp --sport 1024:65535 --dport $HELPER_SSH_PORT --syn -m state --state ESTABLISHED,RELATED -j ACCEPT
	   $IPT $IPT_FLAGS -A INPUT  -p udp --dport $HELPER_SSH_PORT -m state --state ESTABLISHED -j ACCEPT

	   if [ "$USE_IPV6" == "1" ]; then
         $IP6T -A INPUT -m state --state NEW -m tcp -p tcp --dport $HELPER_SSH_PORT -j ACCEPT
      fi
	fi
fi

# Traceroute
if [ "$TCR_PASS" == "1" ]; then
	if [ $EXECUTOR == "nft" ]; then
	   $NFT add rule ip filter INPUT ct state new  udp dport $TCR_PORTS counter accept
	   $NFT add rule ip filter OUTPUT ct state new  udp dport $TCR_PORTS counter accept
   else
      $IPT $IPT_FLAGS -A INPUT  -p udp -m state --state NEW --dport $TCR_PORTS -j ACCEPT
      $IPT $IPT_FLAGS -A OUTPUT  -p udp -m state --state NEW --dport $TCR_PORTS -j ACCEPT
	fi
fi


if [ "$LOG_DROP" == "1" ]; then
    # Default TCP/UDP INPUT log chain
    if [ $EXECUTOR == "nft" ]; then
	    $NFT add rule ip filter INPUT ip protocol tcp limit rate $LOG_RATE/minute burst 5 packets counter log prefix '"** IN_TCP DROP ** "' level $LOG_LEVEL $LEXT
	    $NFT add rule ip filter INPUT ip protocol udp limit rate $LOG_RATE/minute burst 5 packets counter log prefix '"** IN_UDP DROP ** "' level $LOG_LEVEL $LEXT
    else
       $IPT $IPT_FLAGS -A INPUT -p tcp -m limit --limit $LOG_RATE/minute  -j $LOG_TARGET --log-level=$LOG_LEVEL $LEXT --log-prefix "** IN_TCP DROP ** "
       $IPT $IPT_FLAGS -A INPUT -p udp -m limit --limit $LOG_RATE/minute  -j $LOG_TARGET --log-level=$LOG_LEVEL $LEXT --log-prefix "** IN_UDP DROP ** "
	 fi
fi

if [ "$LOG_DROP" == "1" ] && [ "$EGF" == "1" ]; then
    # Default TCP/UDP OUTPUT log chain
    if [ $EXECUTOR == "nft" ]; then
	    $NFT add rule ip filter OUTPUT ip protocol tcp limit rate $LOG_RATE/minute burst 5 packets counter log prefix '"** OUT_TCP DROP ** "' level $LOG_LEVEL $LEXT
	    $NFT add rule ip filter OUTPUT ip protocol udp limit rate $LOG_RATE/minute burst 5 packets counter log prefix '"** OUT_UDP DROP ** "' level $LOG_LEVEL $LEXT
    else
       $IPT $IPT_FLAGS -A OUTPUT -p tcp -m limit --limit $LOG_RATE/minute  -j $LOG_TARGET --log-level=$LOG_LEVEL $LEXT --log-prefix "** OUT_TCP DROP ** "
       $IPT $IPT_FLAGS -A OUTPUT -p udp -m limit --limit $LOG_RATE/minute  -j $LOG_TARGET --log-level=$LOG_LEVEL $LEXT --log-prefix "** OUT_UDP DROP ** "
	 fi
fi


# ECNSHAME
if [ "$SYSCTL_ECN" == "1" ]; then
	dlist_ecnshame
	dlist_ecnshame_hosts
fi

# Load our POSTROUTE rules
tosroute POSTROUTING
. $POSTRT

# Default Output Policies
if [ ! "$EGF" == "1" ] || [ "$EGF" == "" ]; then
	if [ $EXECUTOR == "nft" ]; then
	   $NFT add rule ip filter OUTPUT counter accept
   else
      $IPT $IPT_FLAGS -A OUTPUT -j ACCEPT
	fi
   eout "{glob} default (egress) output accept"
elif [ "$EGF" == "1" ]; then
	if [ $EXECUTOR == "nft" ]; then
	   $NFT add rule ip filter OUTPUT ip protocol tcp counter jump $TCP_STOP
	   $NFT add rule ip filter OUTPUT ip protocol udp counter jump $UDP_STOP
	   $NFT add rule ip filter OUTPUT counter jump $ALL_STOP
   else
	   $IPT $IPT_FLAGS -A OUTPUT -p tcp -j $TCP_STOP
	   $IPT $IPT_FLAGS -A OUTPUT -p udp -j $UDP_STOP
      $IPT $IPT_FLAGS -A OUTPUT -p all -j $ALL_STOP
	fi
   eout "{glob} default (egress) output drop"
fi

# Default Input Policies
eout "{glob} default (ingress) input drop"
if [ $EXECUTOR == "nft" ]; then
   nft add rule ip filter INPUT ip protocol tcp counter $TCP_STOP
   nft add rule ip filter INPUT ip protocol udp counter $UDP_STOP
   nft add rule ip filter INPUT counter $ALL_STOP
   if [ "$USE_IPV6" == "1" ]; then
      $NFT add rule ip6 filter INPUT meta l4proto tcp counter $TCP_STOP
      $NFT add rule ip6 filter INPUT meta l4proto udp counter $UDP_STOP
      $NFT add rule ip6 filter INPUT counter $ALL_STOP
   fi
else
   $IPT $IPT_FLAGS -A INPUT -p tcp -j $TCP_STOP
   $IPT $IPT_FLAGS -A INPUT -p udp -j $UDP_STOP
   $IPT $IPT_FLAGS -A INPUT -p all -j $ALL_STOP
   if [ "$USE_IPV6" == "1" ]; then
        $IP6T -A INPUT -p tcp -j $TCP_STOP
        $IP6T -A INPUT -p udp -j $UDP_STOP
        $IP6T -A INPUT -p all -j $ALL_STOP
   fi
fi

# Restarting Docker
if [ "$SET_DOCKER" == "1" ]; then
        eout "{glob} restarting docker"
	service docker restart
	. $DOCKERR
fi
